
# generateDID generates a new DID in the wallets
import json
import codecs
import hashlib
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.asymmetric import padding

GLOBAL_DID = 0
GLOBAL_PRIV = bytearray()
GLOBAL_PUB = bytearray()


# function to administrator issues DID identifier to both client and server

def generateDIDentity(wallet, controller, pathpubKey, pathprivKey):

    # Global variable to store DID and send to generateDIDadmin method
    global GLOBAL_DID
    # Global variable to store private key and send to generateDIDadmin method
    global GLOBAL_PRIV
    # Global variable to store public key and send to generateDIDadmin method
    global GLOBAL_PUB

    # Open wallet
    with open(wallet) as wallet_file:
        data = json.load(wallet_file)
        temp = data['dids']

        # Recover private key of client/server
        with open(pathprivKey) as f:
            privKey = f.read()
            privKey = privKey.replace('\n', '')

        # Recover public key of client/server
        with open(pathpubKey) as f:
            pubKey = f.read()
            pubKey = pubKey.replace('\n', '')

        # Create DID identifier
        did = "did:vtn:trustid:" + \
            str(hashlib.sha256(pubKey.encode('utf-8')).hexdigest()
                )

        # Generate admin private key    https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa.html#generation
        private_key = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend())

        # Use client/server DID as message to be signed
        message = did.encode('utf-8')

        # signed message https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa.html#signing
        signature = private_key.sign(message, padding.PSS(mgf=padding.MGF1(
            hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH), hashes.SHA256())

        # Parsing data type from bytes to hex
        signature_coded = codecs.encode(signature, 'hex_codec')

        # Object creation
        y = {
            "did": did,
            "controller": controller,
            "pubKey": pubKey,
            "privKey": privKey,
            "signature": signature_coded.decode('utf-8'),
        }

        # Object added
        temp.append(y)

        # Private Key serialization without encryption: https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa.html#key-serialization
        priv_key_pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.TraditionalOpenSSL, encryption_algorithm=serialization.NoEncryption())

        # Parsing data type from bytes to hex
        GLOBAL_PRIV = codecs.encode(priv_key_pem, 'hex_codec')

        # Public Key serialization without encryption: https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa.html#key-serialization
        public_key = private_key.public_key()
        public_key_pem = public_key.public_bytes(
            encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo)

        # Parsing data type from bytes to hex
        GLOBAL_PUB = codecs.encode(public_key_pem, 'hex_codec')

        # Create DID identifier for administrator
        did = "did:vtn:trustid:" + \
            str(hashlib.sha256(public_key_pem).hexdigest()
                )
        GLOBAL_DID = did

    # Object added to Json file
    with open(wallet, 'w') as wallet_file:
        json.dump(data, wallet_file, indent=4)


# administrator DID generated by administrator #########################################

def generateDIDadmin(wallet, controller):
    # Open wallet
    with open(wallet) as wallet_file:
        data = json.load(wallet_file)
        temp = data['dids']

        y = {
            # DID retrieved from GLOBAL variable
            "did": GLOBAL_DID,
            "controller": controller,
            # GLOBAL variable decoded before sending to wallet
            "privKey": GLOBAL_PRIV.decode('utf-8'),
            # GLOBAL variable decoded before sending to wallet
            "pubKey": GLOBAL_PUB.decode('utf-8'),
        }
        temp.append(y)

    # Object added to Json file
    with open(wallet, 'w') as wallet_file:
        json.dump(data, wallet_file, indent=4)
