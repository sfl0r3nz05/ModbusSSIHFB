import random
import hashlib
# DiffieHellman class enables construction of keys capable of performing
# D-H exchanges, and interactive proof of knowledge

class DiffieHellman:
  def __init__(self, G, P, secret):
    self.G = G
    self.P = P
    self.secret = secret
    if (self.secret == 0):
      self.secret = random.randrange(1 << (self.G.bit_length() - 1), self.G - 1)
    self.public = pow(int(self.G), self.secret, int(self.P))

  def prove_shared_secret(self, remote_pub):
    G = self.G; prover_pub = self.public; phi = self. P - 1
    secret = self.get_shared_secret(remote_pub)
    # Random key in the group Z_q
    randKey = DiffieHellman(self.G, self.P, self.secret) # random secret
    commit1 = randKey.public
    commit2 = randKey.get_shared_secret(remote_pub)
    # shift and hash
    concat = str(G) + str(prover_pub) + str(remote_pub) + str(secret) + str(commit1) + str(commit2)
    h = hashlib.md5()
    h.update(concat.encode("utf-8"))
    challenge = int(h.hexdigest(), 16)
    product = (self.secret * challenge) % phi
    response = (randKey.secret - product) % phi
    return (secret, challenge, response)

  def get_shared_secret(self, remote_pub):
    return pow(remote_pub, self.secret, self.P)
    # Verifies proof generated above. Verifier c is showing that
    # shared secret between A and B was generated by A.
    # returns 0 if if verification fails; returns shared secret otherwise

  def verify_shared_secret(self, prover_pub, remote_pub, secret, challenge,
     response):
    P = self.P; G = self.G ; public = self.public

        # g^r * (a's public key)^challenge
    commit1 = (pow(G, response, P) * pow(public, challenge, P)) % P

        # (b's public key)^response * (secret)^challenge
    commit2 = (pow(remote_pub, response, P) * pow(secret, challenge, P)) % P

        # Shift and hash
    hasher = hashlib.md5()
    concat = str(G) + str(prover_pub) + str(remote_pub) + str(secret) + str(commit1) + str(commit2)
    hasher.update(concat.encode("utf-8"))
    check = int(hasher.hexdigest(), 16)

    if challenge == check:
      return secret
    else:
      return 0 